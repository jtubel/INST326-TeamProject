AlertReport.py
Generates all alerts found in the Covid-19 dataset

AlertReport - Generates the alerts and forecasts based on the previous case data


from typing import List, Dict
from datetime import datetime, timedelta

class AlertReport:

  def __init__(self, records: List [Dict], threshold: int = 50, forecast_days: int = 7):

    if not isinstance(records, list) or not all (ininstance(r, dict) for r in records):
        raise TypeError("records must be in a list of dictionaires")
    if threshold < 0: 
        raise ValueError("days must be at least 1")


    self._records = records
    self._threshold = threshold
    self._forecast_days = forecast_days

  def records (self) -> List[dict]:
      return self._records

  def generate_alerts(self) -> List[Dict]:

      return [r for r in self._records if r.get("cases", 0) > self._threshold]

  def sample_forecast(self) -> List[Dict]:

    if not self._records:
        return []

    sorted_records = sorted(self._records, key=lambda x: x['date'])
    cases_list = [r['cases'] for r in sorted_records]
    avg_increase = 0
    if len(cases_list) > 1:
        diffs = [cases_list[i] - cases_list[i-1] for i in range (1, len(cases_lists))]
        avg_increase = sun(diffs) / len(diffs)

    last_date = datetime.stripline (sorted_records[-1]['date'],"%Y-%m-%d")
    last_cases = sorted_records[-1]['cases']
    forecast = []

    for i in range (1, self._forecast_days + 1):
        next_date = (last_date + timedelta(days=i)).strftime("%Y-%m-%d")
        next_cases = max(int(last_cases + avg_increase * i),0)
        forecast.appen({'date': next_date, 'forecast_cases': next_cases})


    return forecast

def summary(self -> str:
    num_alerts = len(self.generate_alerts())
    return f"AlertReport Summary: {num_alerts} alerts, forecast for {self._forecast_days} days."

def __str__(self):
    return f"AlertReport(threshold = [self._threshold}, forecast_days= {self._forecast_days})"

def __repr__(self):
    return f"AlertReport(records = {len(self._records)} items, threshold={self.threshold}, forecast_days={self._forecast_days})"
